{"ast":null,"code":"import { Injectable, NgZone, RendererFactory2, Inject, PLATFORM_ID, ElementRef } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, merge, fromEvent, of, animationFrameScheduler } from 'rxjs';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Get CSS computed property of the given element\n * @param {?} element\n * @param {?=} property\n * @return {?}\n */\nimport * as ɵngcc0 from '@angular/core';\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  /** @type {?} */\n  const window = element.ownerDocument.defaultView;\n  /** @type {?} */\n  const css = window.getComputedStyle(element, null);\n  return property ? css[/** @type {?} */property] : css;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Returns the parentNode or the host of the element\n * @param {?} element\n * @return {?}\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n    default:\n  }\n  // Firefox want us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getStyleComputedProperty(element);\n  if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n    return element;\n  }\n  return getScrollParent(getParentNode(element));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst isIE11 = isBrowser && !!( /** @type {?} */window.MSInputMethodContext && /** @type {?} */document.documentMode);\n/** @type {?} */\nconst isIE10 = isBrowser && !!( /** @type {?} */window.MSInputMethodContext && /MSIE 10/.test( /** @type {?} */navigator.userAgent));\n/**\n * @param {?=} version\n * @return {?}\n */\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n  /** @type {?} */\n  const noOffsetParent = isIE(10) ? document.body : null;\n  // NOTE: 1 DOM access here\n  /** @type {?} */\n  let offsetParent = element.offsetParent || null;\n  // Skip hidden elements which don't have an offsetParent\n  /** @type {?} */\n  let sibling;\n  while (offsetParent === noOffsetParent && element.nextElementSibling && sibling !== element.nextElementSibling) {\n    sibling = element.nextElementSibling;\n    offsetParent = sibling.offsetParent;\n  }\n  /** @type {?} */\n  const nodeName = offsetParent && offsetParent.nodeName;\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n  }\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n  return offsetParent;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction isOffsetContainer(element) {\n  const {\n    nodeName\n  } = element;\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @param {?} node\n * @return {?}\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n  return node;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element1\n * @param {?} element2\n * @return {?}\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  /* tslint:disable-next-line: no-bitwise */\n  /** @type {?} */\n  const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  /** @type {?} */\n  const start = order ? element1 : element2;\n  /** @type {?} */\n  const end = order ? element2 : element1;\n  // Get common ancestor container\n  /** @type {?} */\n  const range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  const {\n    commonAncestorContainer\n  } = range;\n  // Both nodes are inside #document\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n    return getOffsetParent(commonAncestorContainer);\n  }\n  // one of the nodes is inside shadowDOM, find which one\n  /** @type {?} */\n  const element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Helper to detect borders of a given element\n */\n/**\n * @param {?} styles\n * @param {?} axis\n * @return {?}\n */\nfunction getBordersSize(styles, axis) {\n  /** @type {?} */\n  const sideA = axis === 'x' ? 'Left' : 'Top';\n  /** @type {?} */\n  const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n  return parseFloat(styles[/** @type {?} */`border${sideA}Width`]) + parseFloat(styles[/** @type {?} */`border${sideB}Width`]);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} axis\n * @param {?} body\n * @param {?} html\n * @param {?} computedStyle\n * @return {?}\n */\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max( /** @type {?} */body[`offset${axis}`], /** @type {?} */body[`scroll${axis}`], /** @type {?} */html[`client${axis}`], /** @type {?} */html[`offset${axis}`], /** @type {?} */html[`scroll${axis}`], isIE(10) ? parseInt( /** @type {?} */html[`offset${axis}`], 10) + parseInt(computedStyle[/** @type {?} */`margin${axis === 'Height' ? 'Top' : 'Left'}`], 10) + parseInt(computedStyle[/** @type {?} */`margin${axis === 'Height' ? 'Bottom' : 'Right'}`], 10) : 0);\n}\n/**\n * @param {?} document\n * @return {?}\n */\nfunction getWindowSizes(document) {\n  /** @type {?} */\n  const body = document.body;\n  /** @type {?} */\n  const html = document.documentElement;\n  /** @type {?} */\n  const computedStyle = isIE(10) && getComputedStyle(html);\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @param {?} element\n * @param {?=} side\n * @return {?}\n */\nfunction getScroll(element, side = 'top') {\n  /** @type {?} */\n  const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  /** @type {?} */\n  const nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    /** @type {?} */\n    const html = element.ownerDocument.documentElement;\n    /** @type {?} */\n    const scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n  return element[upperSide];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} offsets\n * @return {?}\n */\nfunction getClientRect(offsets) {\n  return Object.assign(Object.assign({}, offsets), {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction getBoundingClientRect(element) {\n  /** @type {?} */\n  let rect = {};\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      /** @type {?} */\n      const scrollTop = getScroll(element, 'top');\n      /** @type {?} */\n      const scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {\n    return undefined;\n  }\n  /** @type {?} */\n  const result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n  // subtract scrollbar size from sizes\n  /** @type {?} */\n  const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  /** @type {?} */\n  const width = sizes.width || element.clientWidth || result.right - result.left;\n  /** @type {?} */\n  const height = sizes.height || element.clientHeight || result.bottom - result.top;\n  /** @type {?} */\n  let horizScrollbar = element.offsetWidth - width;\n  /** @type {?} */\n  let vertScrollbar = element.offsetHeight - height;\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    /** @type {?} */\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n  return getClientRect(result);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} rect\n * @param {?} element\n * @param {?=} subtract\n * @return {?}\n */\nfunction includeScroll(rect, element, subtract = false) {\n  /** @type {?} */\n  const scrollTop = getScroll(element, 'top');\n  /** @type {?} */\n  const scrollLeft = getScroll(element, 'left');\n  /** @type {?} */\n  const modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} children\n * @param {?} parent\n * @param {?=} fixedPosition\n * @return {?}\n */\nfunction getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition = false) {\n  /** @type {?} */\n  const isIE10 = isIE(10);\n  /** @type {?} */\n  const isHTML = parent.nodeName === 'HTML';\n  /** @type {?} */\n  const childrenRect = getBoundingClientRect(children);\n  /** @type {?} */\n  const parentRect = getBoundingClientRect(parent);\n  /** @type {?} */\n  const scrollParent = getScrollParent(children);\n  /** @type {?} */\n  const styles = getStyleComputedProperty(parent);\n  /** @type {?} */\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  /** @type {?} */\n  const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  /** @type {?} */\n  let offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    /** @type {?} */\n    const marginTop = parseFloat(styles.marginTop);\n    /** @type {?} */\n    const marginLeft = parseFloat(styles.marginLeft);\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n  return offsets;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @param {?=} excludeScroll\n * @return {?}\n */\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) {\n  /** @type {?} */\n  const html = element.ownerDocument.documentElement;\n  /** @type {?} */\n  const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  /** @type {?} */\n  const width = Math.max(html.clientWidth, window.innerWidth || 0);\n  /** @type {?} */\n  const height = Math.max(html.clientHeight, window.innerHeight || 0);\n  /** @type {?} */\n  const scrollTop = !excludeScroll ? getScroll(html) : 0;\n  /** @type {?} */\n  const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n  /** @type {?} */\n  const offset = {\n    top: scrollTop - Number(relativeOffset.top) + Number(relativeOffset.marginTop),\n    left: scrollLeft - Number(relativeOffset.left) + Number(relativeOffset.marginLeft),\n    width,\n    height\n  };\n  return getClientRect(offset);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction isFixed(element) {\n  /** @type {?} */\n  const nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  return isFixed(getParentNode(element));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  /** @type {?} */\n  let el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} target\n * @param {?} host\n * @param {?=} padding\n * @param {?=} boundariesElement\n * @param {?=} fixedPosition\n * @return {?}\n */\nfunction getBoundaries(target, host, padding = 0, boundariesElement, fixedPosition = false) {\n  // NOTE: 1 DOM access here\n  // NOTE: 1 DOM access here\n  /** @type {?} */\n  let boundaries = {\n    top: 0,\n    left: 0\n  };\n  /** @type {?} */\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    /** @type {?} */\n    let boundariesNode;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(host));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = target.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = target.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n    /** @type {?} */\n    const offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      const {\n        height,\n        width\n      } = getWindowSizes(target.ownerDocument);\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = Number(height) + Number(offsets.top);\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = Number(width) + Number(offsets.left);\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n  // Add paddings\n  boundaries.left += padding;\n  boundaries.top += padding;\n  boundaries.right -= padding;\n  boundaries.bottom -= padding;\n  return boundaries;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction getArea({\n  width,\n  height\n}) {\n  return width * height;\n}\n/**\n * @param {?} placement\n * @param {?} refRect\n * @param {?} target\n * @param {?} host\n * @param {?=} allowedPositions\n * @param {?=} boundariesElement\n * @param {?=} padding\n * @return {?}\n */\nfunction computeAutoPlacement(placement, refRect, target, host, allowedPositions = ['top', 'bottom', 'right', 'left'], boundariesElement = 'viewport', padding = 0) {\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n  /** @type {?} */\n  const boundaries = getBoundaries(target, host, padding, boundariesElement);\n  /** @type {?} */\n  const rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n  /** @type {?} */\n  const sortedAreas = Object.keys(rects).map(\n  /**\n  * @param {?} key\n  * @return {?}\n  */\n  key => Object.assign(Object.assign({\n    key\n  }, rects[key]), {\n    area: getArea(rects[key])\n  })).sort(\n  /**\n  * @param {?} a\n  * @param {?} b\n  * @return {?}\n  */\n  (a, b) => b.area - a.area);\n  /** @type {?} */\n  let filteredAreas = sortedAreas.filter(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  ({\n    width,\n    height\n  }) => {\n    return width >= target.clientWidth && height >= target.clientHeight;\n  });\n  filteredAreas = filteredAreas.filter(\n  /**\n  * @param {?} position\n  * @return {?}\n  */\n  position => {\n    return allowedPositions.some(\n    /**\n    * @param {?} allowedPosition\n    * @return {?}\n    */\n    allowedPosition => {\n      return allowedPosition === position.key;\n    });\n  });\n  /** @type {?} */\n  const computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n  /** @type {?} */\n  const variation = placement.split(' ')[1];\n  // for tooltip on auto position\n  target.className = target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${computedPlacement}`);\n  return computedPlacement + (variation ? `-${variation}` : '');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction getOffsets(data) {\n  return {\n    width: data.offsets.target.width,\n    height: data.offsets.target.height,\n    left: Math.floor(data.offsets.target.left),\n    top: Math.round(data.offsets.target.top),\n    bottom: Math.round(data.offsets.target.bottom),\n    right: Math.floor(data.offsets.target.right)\n  };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Get the opposite placement of the given one\n * @param {?} placement\n * @return {?}\n */\nfunction getOppositePlacement(placement) {\n  /** @type {?} */\n  const hash = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  return placement.replace(/left|right|bottom|top/g,\n  /**\n  * @param {?} matched\n  * @return {?}\n  */\n  matched => /** @type {?} */hash[matched]);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Get the opposite placement variation of the given one\n * @param {?} variation\n * @return {?}\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'right') {\n    return 'left';\n  } else if (variation === 'left') {\n    return 'right';\n  }\n  return variation;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @param {?} element\n * @return {?}\n */\nfunction getOuterSizes(element) {\n  /** @type {?} */\n  const window = element.ownerDocument.defaultView;\n  /** @type {?} */\n  const styles = window.getComputedStyle(element);\n  /** @type {?} */\n  const x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  /** @type {?} */\n  const y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  return {\n    width: Number(element.offsetWidth) + y,\n    height: Number(element.offsetHeight) + x\n  };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} target\n * @param {?} host\n * @param {?=} fixedPosition\n * @return {?}\n */\nfunction getReferenceOffsets(target, host, fixedPosition = null) {\n  /** @type {?} */\n  const commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n  return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} target\n * @param {?} hostOffsets\n * @param {?} position\n * @return {?}\n */\nfunction getTargetOffsets(target, hostOffsets, position) {\n  /** @type {?} */\n  const placement = position.split(' ')[0];\n  // Get target node sizes\n  /** @type {?} */\n  const targetRect = getOuterSizes(target);\n  // Add position, width and height to our offsets object\n  /** @type {?} */\n  const targetOffsets = {\n    width: targetRect.width,\n    height: targetRect.height\n  };\n  // depending by the target placement we have to compute its offsets slightly differently\n  /** @type {?} */\n  const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  /** @type {?} */\n  const mainSide = isHoriz ? 'top' : 'left';\n  /** @type {?} */\n  const secondarySide = isHoriz ? 'left' : 'top';\n  /** @type {?} */\n  const measurement = isHoriz ? 'height' : 'width';\n  /** @type {?} */\n  const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n  /** @type {?} */targetOffsets[mainSide] = hostOffsets[mainSide] + hostOffsets[measurement] / 2 - targetRect[measurement] / 2;\n  /** @type {?} */targetOffsets[secondarySide] = placement === secondarySide ? hostOffsets[secondarySide] - targetRect[secondaryMeasurement] : /** @type {?} */hostOffsets[getOppositePlacement(secondarySide)];\n  return targetOffsets;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Helper used to know if the given modifier is enabled.\n * @param {?} options\n * @param {?} modifierName\n * @return {?}\n */\nfunction isModifierEnabled(options, modifierName) {\n  return options && options.modifiers && options.modifiers[modifierName] && options.modifiers[modifierName].enabled;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Tells if a given input is a number\n * @param {?} n\n * @return {?}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @param {?=} renderer\n * @return {?}\n */\nfunction updateContainerClass(data, renderer) {\n  /** @type {?} */\n  const target = data.instance.target;\n  /** @type {?} */\n  let containerClass = target.className;\n  if (data.placementAuto) {\n    containerClass = containerClass.replace(/bs-popover-auto/g, `bs-popover-${data.placement}`);\n    containerClass = containerClass.replace(/bs-tooltip-auto/g, `bs-tooltip-${data.placement}`);\n    containerClass = containerClass.replace(/\\sauto/g, ` ${data.placement}`);\n    if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\n      containerClass += ' popover-auto';\n    }\n    if (containerClass.indexOf('tooltip') !== -1 && containerClass.indexOf('tooltip-auto') === -1) {\n      containerClass += ' tooltip-auto';\n    }\n  }\n  containerClass = containerClass.replace(/left|right|top|bottom/g, `${data.placement.split(' ')[0]}`);\n  if (renderer) {\n    renderer.setAttribute(target, 'class', containerClass);\n    return;\n  }\n  target.className = containerClass;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @param {?} styles\n * @param {?=} renderer\n * @return {?}\n */\nfunction setStyles(element, styles, renderer) {\n  Object.keys(styles).forEach(\n  /**\n  * @param {?} prop\n  * @return {?}\n  */\n  prop => {\n    /** @type {?} */\n    let unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    if (renderer) {\n      renderer.setStyle(element, prop, `${String(styles[prop])}${unit}`);\n      return;\n    }\n    element.style[prop] = String(styles[prop]) + unit;\n  });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction arrow(data) {\n  /** @type {?} */\n  let targetOffsets = data.offsets.target;\n  // if arrowElement is a string, suppose it's a CSS selector\n  /** @type {?} */\n  const arrowElement = data.instance.target.querySelector('.arrow');\n  // if arrowElement is not found, don't run the modifier\n  if (!arrowElement) {\n    return data;\n  }\n  /** @type {?} */\n  const isVertical = ['left', 'right'].indexOf(data.placement.split(' ')[0]) !== -1;\n  /** @type {?} */\n  const len = isVertical ? 'height' : 'width';\n  /** @type {?} */\n  const sideCapitalized = isVertical ? 'Top' : 'Left';\n  /** @type {?} */\n  const side = sideCapitalized.toLowerCase();\n  /** @type {?} */\n  const altSide = isVertical ? 'left' : 'top';\n  /** @type {?} */\n  const opSide = isVertical ? 'bottom' : 'right';\n  /** @type {?} */\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n  /** @type {?} */\n  const placementVariation = data.placement.split(' ')[1];\n  // top/left side\n  if (data.offsets.host[opSide] - arrowElementSize < /** @type {?} */targetOffsets[side]) {\n    /** @type {?} */targetOffsets[side] -= /** @type {?} */targetOffsets[side] - (data.offsets.host[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (Number( /** @type {?} */data.offsets.host[side]) + Number(arrowElementSize) > /** @type {?} */targetOffsets[opSide]) {\n    /** @type {?} */targetOffsets[side] += Number( /** @type {?} */data.offsets.host[side]) + Number(arrowElementSize) - Number( /** @type {?} */targetOffsets[opSide]);\n  }\n  targetOffsets = getClientRect(targetOffsets);\n  // Compute the sideValue using the updated target offsets\n  // take target margin in account because we don't have this info available\n  /** @type {?} */\n  const css = getStyleComputedProperty(data.instance.target);\n  /** @type {?} */\n  const targetMarginSide = parseFloat(css[`margin${sideCapitalized}`]);\n  /** @type {?} */\n  const targetBorderSide = parseFloat(css[`border${sideCapitalized}Width`]);\n  // compute center of the target\n  /** @type {?} */\n  let center;\n  if (!placementVariation) {\n    center = Number( /** @type {?} */data.offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n  } else {\n    /** @type {?} */\n    const targetBorderRadius = parseFloat(css.borderRadius);\n    /** @type {?} */\n    const targetSideArrowOffset = Number(targetMarginSide + targetBorderSide + targetBorderRadius);\n    center = side === placementVariation ? Number( /** @type {?} */data.offsets.host[side]) + targetSideArrowOffset : Number( /** @type {?} */data.offsets.host[side]) + Number(data.offsets.host[len] - targetSideArrowOffset);\n  }\n  /** @type {?} */\n  let sideValue = center - /** @type {?} */targetOffsets[side] - targetMarginSide - targetBorderSide;\n  // prevent arrowElement from being placed not contiguously to its target\n  sideValue = Math.max(Math.min(targetOffsets[len] - arrowElementSize, sideValue), 0);\n  data.offsets.arrow = {\n    [side]: Math.round(sideValue),\n    [altSide]: '' // make sure to unset any eventual altSide value from the DOM node\n  };\n\n  data.instance.arrow = arrowElement;\n  return data;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction flip(data) {\n  data.offsets.target = getClientRect(data.offsets.target);\n  if (!isModifierEnabled(data.options, 'flip')) {\n    data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n    return data;\n  }\n  /** @type {?} */\n  const boundaries = getBoundaries(data.instance.target, data.instance.host, 0,\n  // padding\n  'viewport', false // positionFixed\n  );\n  /** @type {?} */\n  let placement = data.placement.split(' ')[0];\n  /** @type {?} */\n  let variation = data.placement.split(' ')[1] || '';\n  /** @type {?} */\n  const offsetsHost = data.offsets.host;\n  /** @type {?} */\n  const target = data.instance.target;\n  /** @type {?} */\n  const host = data.instance.host;\n  /** @type {?} */\n  const adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\n  /** @type {?} */\n  const flipOrder = [placement, adaptivePosition];\n  /* tslint:disable-next-line: cyclomatic-complexity */\n  flipOrder.forEach(\n  /**\n  * @param {?} step\n  * @param {?} index\n  * @return {?}\n  */\n  (step, index) => {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n    placement = data.placement.split(' ')[0];\n    // using floor because the host offsets may contain decimals we are not going to consider here\n    /** @type {?} */\n    const overlapsRef = placement === 'left' && Math.floor(data.offsets.target.right) > Math.floor(data.offsets.host.left) || placement === 'right' && Math.floor(data.offsets.target.left) < Math.floor(data.offsets.host.right) || placement === 'top' && Math.floor(data.offsets.target.bottom) > Math.floor(data.offsets.host.top) || placement === 'bottom' && Math.floor(data.offsets.target.top) < Math.floor(data.offsets.host.bottom);\n    /** @type {?} */\n    const overflowsLeft = Math.floor(data.offsets.target.left) < Math.floor(boundaries.left);\n    /** @type {?} */\n    const overflowsRight = Math.floor(data.offsets.target.right) > Math.floor(boundaries.right);\n    /** @type {?} */\n    const overflowsTop = Math.floor(data.offsets.target.top) < Math.floor(boundaries.top);\n    /** @type {?} */\n    const overflowsBottom = Math.floor(data.offsets.target.bottom) > Math.floor(boundaries.bottom);\n    /** @type {?} */\n    const overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n    // flip the variation if required\n    /** @type {?} */\n    const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    /** @type {?} */\n    const flippedVariation = isVertical && variation === 'left' && overflowsLeft || isVertical && variation === 'right' && overflowsRight || !isVertical && variation === 'left' && overflowsTop || !isVertical && variation === 'right' && overflowsBottom;\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n      data.placement = placement + (variation ? ` ${variation}` : '');\n      data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n    }\n  });\n  return data;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} targetElement\n * @param {?} hostElement\n * @param {?} position\n * @param {?} options\n * @return {?}\n */\nfunction initData(targetElement, hostElement, position, options) {\n  /** @type {?} */\n  const hostElPosition = getReferenceOffsets(targetElement, hostElement);\n  if (!position.match(/^(auto)*\\s*(left|right|top|bottom)*$/) && !position.match(/^(left|right|top|bottom)*(?: (left|right|top|bottom))?\\s*(start|end)*$/)) {\n    /* tslint:disable-next-line: no-parameter-reassignment */\n    position = 'auto';\n  }\n  /** @type {?} */\n  const placementAuto = !!position.match(/auto/g);\n  // support old placements 'auto left|right|top|bottom'\n  /** @type {?} */\n  let placement = position.match(/auto\\s(left|right|top|bottom)/) ? position.split(' ')[1] || 'auto' : position;\n  // Normalize placements that have identical main placement and variation (\"right right\" => \"right\").\n  /** @type {?} */\n  const matches = placement.match(/^(left|right|top|bottom)* ?(?!\\1)(left|right|top|bottom)?/);\n  if (matches) {\n    placement = matches[1] + (matches[2] ? ` ${matches[2]}` : '');\n  }\n  // \"left right\", \"top bottom\" etc. placements also considered incorrect.\n  if (['left right', 'right left', 'top bottom', 'bottom top'].indexOf(placement) !== -1) {\n    placement = 'auto';\n  }\n  /** @type {?} */\n  const targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n  placement = computeAutoPlacement(placement, hostElPosition, targetElement, hostElement, options ? options.allowedPositions : undefined);\n  return {\n    options,\n    instance: {\n      target: targetElement,\n      host: hostElement,\n      arrow: null\n    },\n    offsets: {\n      target: targetOffset,\n      host: hostElPosition,\n      arrow: null\n    },\n    positionFixed: false,\n    placement,\n    placementAuto\n  };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction preventOverflow(data) {\n  if (!isModifierEnabled(data.options, 'preventOverflow')) {\n    return data;\n  }\n  // NOTE: DOM access here\n  // resets the targetOffsets's position so that the document size can be calculated excluding\n  // the size of the targetOffsets element itself\n  /** @type {?} */\n  const transformProp = 'transform';\n  /** @type {?} */\n  const targetStyles = data.instance.target.style;\n  // assignment to help minification\n  const {\n    top,\n    left,\n    [transformProp]: transform\n  } = targetStyles;\n  targetStyles.top = '';\n  targetStyles.left = '';\n  targetStyles[transformProp] = '';\n  /** @type {?} */\n  const boundaries = getBoundaries(data.instance.target, data.instance.host, 0,\n  // padding\n  'scrollParent', false // positionFixed\n  );\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  targetStyles.top = top;\n  targetStyles.left = left;\n  targetStyles[transformProp] = transform;\n  /** @type {?} */\n  const order = ['left', 'right', 'top', 'bottom'];\n  /** @type {?} */\n  const check = {\n    /**\n     * @param {?} placement\n     * @return {?}\n     */\n    primary(placement) {\n      /** @type {?} */\n      let value = /** @type {?} */data.offsets.target[placement];\n      if ( /** @type {?} */data.offsets.target[placement] < boundaries[placement] && !false // options.escapeWithReference\n      ) {\n        value = Math.max( /** @type {?} */data.offsets.target[placement], boundaries[placement]);\n      }\n      return {\n        [placement]: value\n      };\n    },\n    /**\n     * @param {?} placement\n     * @return {?}\n     */\n    secondary(placement) {\n      /** @type {?} */\n      const mainSide = placement === 'right' ? 'left' : 'top';\n      /** @type {?} */\n      let value = data.offsets.target[mainSide];\n      if ( /** @type {?} */data.offsets.target[placement] > boundaries[placement] && !false // escapeWithReference\n      ) {\n        value = Math.min(data.offsets.target[mainSide], boundaries[placement] - (placement === 'right' ? data.offsets.target.width : data.offsets.target.height));\n      }\n      return {\n        [mainSide]: value\n      };\n    }\n  };\n  /** @type {?} */\n  let side;\n  order.forEach(\n  /**\n  * @param {?} placement\n  * @return {?}\n  */\n  placement => {\n    side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), /** @type {?} */check[side](placement));\n  });\n  return data;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction shift(data) {\n  /** @type {?} */\n  const placement = data.placement;\n  /** @type {?} */\n  const basePlacement = placement.split(' ')[0];\n  /** @type {?} */\n  const shiftVariation = placement.split(' ')[1];\n  if (shiftVariation) {\n    const {\n      host,\n      target\n    } = data.offsets;\n    /** @type {?} */\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    /** @type {?} */\n    const side = isVertical ? 'left' : 'top';\n    /** @type {?} */\n    const measurement = isVertical ? 'width' : 'height';\n    /** @type {?} */\n    const shiftOffsets = {\n      start: {\n        [side]: host[side]\n      },\n      end: {\n        [side]: host[side] + host[measurement] - target[measurement]\n      }\n    };\n    data.offsets.target = Object.assign(Object.assign({}, target), {\n      [side]: side === shiftVariation ? /** @type {?} */shiftOffsets.start[side] : /** @type {?} */shiftOffsets.end[side]\n    });\n  }\n  return data;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass Positioning {\n  /**\n   * @param {?} hostElement\n   * @param {?} targetElement\n   * @param {?=} round\n   * @return {?}\n   */\n  position(hostElement, targetElement, round = true) {\n    return this.offset(hostElement, targetElement, false);\n  }\n  /**\n   * @param {?} hostElement\n   * @param {?} targetElement\n   * @param {?=} round\n   * @return {?}\n   */\n  offset(hostElement, targetElement, round = true) {\n    return getReferenceOffsets(targetElement, hostElement);\n  }\n  /**\n   * @param {?} hostElement\n   * @param {?} targetElement\n   * @param {?} position\n   * @param {?=} appendToBody\n   * @param {?=} options\n   * @return {?}\n   */\n  positionElements(hostElement, targetElement, position, appendToBody, options) {\n    /** @type {?} */\n    const chainOfModifiers = [flip, shift, preventOverflow, arrow];\n    return chainOfModifiers.reduce(\n    /**\n    * @param {?} modifiedData\n    * @param {?} modifier\n    * @return {?}\n    */\n    (modifiedData, modifier) => modifier(modifiedData), initData(targetElement, hostElement, position, options));\n  }\n}\n/** @type {?} */\nconst positionService = new Positioning();\n/**\n * @param {?} hostElement\n * @param {?} targetElement\n * @param {?} placement\n * @param {?=} appendToBody\n * @param {?=} options\n * @param {?=} renderer\n * @return {?}\n */\nfunction positionElements(hostElement, targetElement, placement, appendToBody, options, renderer) {\n  /** @type {?} */\n  const data = positionService.positionElements(hostElement, targetElement, placement, appendToBody, options);\n  /** @type {?} */\n  const offsets = getOffsets(data);\n  setStyles(targetElement, {\n    'will-change': 'transform',\n    top: '0px',\n    left: '0px',\n    transform: `translate3d(${offsets.left}px, ${offsets.top}px, 0px)`\n  }, renderer);\n  if (data.instance.arrow) {\n    setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n  }\n  updateContainerClass(data, renderer);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nfunction PositioningOptions() {}\nif (false) {\n  /**\n   * The DOM element, ElementRef, or a selector string of an element which will be moved\n   * @type {?|undefined}\n   */\n  PositioningOptions.prototype.element;\n  /**\n   * The DOM element, ElementRef, or a selector string of an element which the element will be attached to\n   * @type {?|undefined}\n   */\n  PositioningOptions.prototype.target;\n  /**\n   * A string of the form 'vert-attachment horiz-attachment' or 'placement'\n   * - placement can be \"top\", \"bottom\", \"left\", \"right\"\n   * not yet supported:\n   * - vert-attachment can be any of 'top', 'middle', 'bottom'\n   * - horiz-attachment can be any of 'left', 'center', 'right'\n   * @type {?|undefined}\n   */\n  PositioningOptions.prototype.attachment;\n  /**\n   * A string similar to `attachment`. The one difference is that, if it's not provided,\n   * `targetAttachment` will assume the mirror image of `attachment`.\n   * @type {?|undefined}\n   */\n  PositioningOptions.prototype.targetAttachment;\n  /**\n   * A string of the form 'vert-offset horiz-offset'\n   * - vert-offset and horiz-offset can be of the form \"20px\" or \"55%\"\n   * @type {?|undefined}\n   */\n  PositioningOptions.prototype.offset;\n  /**\n   * A string similar to `offset`, but referring to the offset of the target\n   * @type {?|undefined}\n   */\n  PositioningOptions.prototype.targetOffset;\n  /**\n   * If true component will be attached to body\n   * @type {?|undefined}\n   */\n  PositioningOptions.prototype.appendToBody;\n}\nclass PositioningService {\n  /**\n   * @param {?} ngZone\n   * @param {?} rendererFactory\n   * @param {?} platformId\n   */\n  constructor(ngZone, rendererFactory, platformId) {\n    this.update$$ = new Subject();\n    this.positionElements = new Map();\n    this.isDisabled = false;\n    if (isPlatformBrowser(platformId)) {\n      ngZone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => {\n        this.triggerEvent$ = merge(fromEvent(window, 'scroll', {\n          passive: true\n        }), fromEvent(window, 'resize', {\n          passive: true\n        }), /* tslint:disable-next-line: deprecation */\n        of(0, animationFrameScheduler), this.update$$);\n        this.triggerEvent$.subscribe(\n        /**\n        * @return {?}\n        */\n        () => {\n          if (this.isDisabled) {\n            return;\n          }\n          this.positionElements\n          /* tslint:disable-next-line: no-any */.forEach(\n          /**\n          * @param {?} positionElement\n          * @return {?}\n          */\n          positionElement => {\n            positionElements(_getHtmlElement(positionElement.target), _getHtmlElement(positionElement.element), positionElement.attachment, positionElement.appendToBody, this.options, rendererFactory.createRenderer(null, null));\n          });\n        });\n      });\n    }\n  }\n  /**\n   * @param {?} options\n   * @return {?}\n   */\n  position(options) {\n    this.addPositionElement(options);\n  }\n  /**\n   * @return {?}\n   */\n  get event$() {\n    return this.triggerEvent$;\n  }\n  /**\n   * @return {?}\n   */\n  disable() {\n    this.isDisabled = true;\n  }\n  /**\n   * @return {?}\n   */\n  enable() {\n    this.isDisabled = false;\n  }\n  /**\n   * @param {?} options\n   * @return {?}\n   */\n  addPositionElement(options) {\n    this.positionElements.set(_getHtmlElement(options.element), options);\n  }\n  /**\n   * @return {?}\n   */\n  calcPosition() {\n    this.update$$.next();\n  }\n  /**\n   * @param {?} elRef\n   * @return {?}\n   */\n  deletePositionElement(elRef) {\n    this.positionElements.delete(_getHtmlElement(elRef));\n  }\n  /**\n   * @param {?} options\n   * @return {?}\n   */\n  setOptions(options) {\n    this.options = options;\n  }\n}\nPositioningService.ɵfac = function PositioningService_Factory(t) {\n  return new (t || PositioningService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2), ɵngcc0.ɵɵinject(PLATFORM_ID));\n};\nPositioningService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: PositioningService,\n  factory: PositioningService.ɵfac\n});\n/** @nocollapse */\nPositioningService.ctorParameters = () => [{\n  type: NgZone\n}, {\n  type: RendererFactory2\n}, {\n  type: Number,\n  decorators: [{\n    type: Inject,\n    args: [PLATFORM_ID]\n  }]\n}];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PositioningService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ɵngcc0.NgZone\n    }, {\n      type: ɵngcc0.RendererFactory2\n    }, {\n      type: Number,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  PositioningService.prototype.options;\n  /**\n   * @type {?}\n   * @private\n   */\n  PositioningService.prototype.update$$;\n  /**\n   * @type {?}\n   * @private\n   */\n  PositioningService.prototype.positionElements;\n  /**\n   * @type {?}\n   * @private\n   */\n  PositioningService.prototype.triggerEvent$;\n  /**\n   * @type {?}\n   * @private\n   */\n  PositioningService.prototype.isDisabled;\n}\n/**\n * @param {?} element\n * @return {?}\n */\nfunction _getHtmlElement(element) {\n  // it means that we got a selector\n  if (typeof element === 'string') {\n    return document.querySelector(element);\n  }\n  if (element instanceof ElementRef) {\n    return element.nativeElement;\n  }\n  return element;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { Positioning, PositioningService, positionElements };","map":{"version":3,"names":["Injectable","NgZone","RendererFactory2","Inject","PLATFORM_ID","ElementRef","isPlatformBrowser","Subject","merge","fromEvent","of","animationFrameScheduler","ɵngcc0","getStyleComputedProperty","element","property","nodeType","window","ownerDocument","defaultView","css","getComputedStyle","getParentNode","nodeName","parentNode","host","getScrollParent","document","body","overflow","overflowX","overflowY","test","String","isBrowser","isIE11","MSInputMethodContext","documentMode","isIE10","navigator","userAgent","isIE","version","getOffsetParent","documentElement","noOffsetParent","offsetParent","sibling","nextElementSibling","indexOf","isOffsetContainer","firstElementChild","getRoot","node","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","element1root","getBordersSize","styles","axis","sideA","sideB","parseFloat","getSize","html","computedStyle","Math","max","parseInt","getWindowSizes","height","width","getScroll","side","upperSide","scrollingElement","getClientRect","offsets","Object","assign","right","left","bottom","top","getBoundingClientRect","rect","scrollTop","scrollLeft","e","undefined","result","sizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","includeScroll","subtract","modifier","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","getViewportOffsetRectRelativeToArtbitraryNode","excludeScroll","relativeOffset","innerWidth","innerHeight","offset","Number","isFixed","getFixedPositionOffsetParent","parentElement","el","getBoundaries","target","padding","boundariesElement","boundaries","boundariesNode","getArea","computeAutoPlacement","placement","refRect","allowedPositions","rects","sortedAreas","keys","map","key","area","sort","a","b","filteredAreas","filter","position","some","allowedPosition","computedPlacement","length","variation","split","className","replace","getOffsets","data","floor","round","getOppositePlacement","hash","matched","getOppositeVariation","getOuterSizes","x","marginBottom","y","marginRight","getReferenceOffsets","commonOffsetParent","getTargetOffsets","hostOffsets","targetRect","targetOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","isModifierEnabled","options","modifierName","modifiers","enabled","isNumeric","n","isNaN","isFinite","updateContainerClass","renderer","instance","containerClass","placementAuto","setAttribute","setStyles","forEach","prop","unit","setStyle","style","arrow","arrowElement","querySelector","isVertical","len","sideCapitalized","toLowerCase","altSide","opSide","arrowElementSize","placementVariation","targetMarginSide","targetBorderSide","center","targetBorderRadius","borderRadius","targetSideArrowOffset","sideValue","min","flip","offsetsHost","adaptivePosition","flipOrder","step","index","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariation","initData","targetElement","hostElement","hostElPosition","match","matches","targetOffset","positionFixed","preventOverflow","transformProp","targetStyles","transform","check","primary","value","secondary","shift","basePlacement","shiftVariation","shiftOffsets","Positioning","positionElements","appendToBody","chainOfModifiers","reduce","modifiedData","positionService","PositioningOptions","prototype","attachment","targetAttachment","PositioningService","constructor","ngZone","rendererFactory","platformId","update$$","Map","isDisabled","runOutsideAngular","triggerEvent$","passive","subscribe","positionElement","_getHtmlElement","createRenderer","addPositionElement","event$","disable","enable","set","calcPosition","next","deletePositionElement","elRef","delete","setOptions","ɵfac","PositioningService_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","factory","ctorParameters","type","decorators","args","ngDevMode","ɵsetClassMetadata","nativeElement"],"sources":["C:/Users/Jussara/Desktop/ProEventos/Front/ProEventos-App/node_modules/ngx-bootstrap/__ivy_ngcc__/positioning/fesm2015/ngx-bootstrap-positioning.js"],"sourcesContent":["import { Injectable, NgZone, RendererFactory2, Inject, PLATFORM_ID, ElementRef } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, merge, fromEvent, of, animationFrameScheduler } from 'rxjs';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Get CSS computed property of the given element\n * @param {?} element\n * @param {?=} property\n * @return {?}\n */\nimport * as ɵngcc0 from '@angular/core';\nfunction getStyleComputedProperty(element, property) {\n    if (element.nodeType !== 1) {\n        return [];\n    }\n    // NOTE: 1 DOM access here\n    /** @type {?} */\n    const window = element.ownerDocument.defaultView;\n    /** @type {?} */\n    const css = window.getComputedStyle(element, null);\n    return property ? css[(/** @type {?} */ (property))] : css;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Returns the parentNode or the host of the element\n * @param {?} element\n * @return {?}\n */\nfunction getParentNode(element) {\n    if (element.nodeName === 'HTML') {\n        return element;\n    }\n    return element.parentNode || element.host;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction getScrollParent(element) {\n    // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n    if (!element) {\n        return document.body;\n    }\n    switch (element.nodeName) {\n        case 'HTML':\n        case 'BODY':\n            return element.ownerDocument.body;\n        case '#document':\n            return element.body;\n        default:\n    }\n    // Firefox want us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n    if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n        return element;\n    }\n    return getScrollParent(getParentNode(element));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst isIE11 = isBrowser && !!(((/** @type {?} */ (window))).MSInputMethodContext && ((/** @type {?} */ (document))).documentMode);\n/** @type {?} */\nconst isIE10 = isBrowser && !!(((/** @type {?} */ (window))).MSInputMethodContext && /MSIE 10/.test(((/** @type {?} */ (navigator))).userAgent));\n/**\n * @param {?=} version\n * @return {?}\n */\nfunction isIE(version) {\n    if (version === 11) {\n        return isIE11;\n    }\n    if (version === 10) {\n        return isIE10;\n    }\n    return isIE11 || isIE10;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction getOffsetParent(element) {\n    if (!element) {\n        return document.documentElement;\n    }\n    /** @type {?} */\n    const noOffsetParent = isIE(10) ? document.body : null;\n    // NOTE: 1 DOM access here\n    /** @type {?} */\n    let offsetParent = element.offsetParent || null;\n    // Skip hidden elements which don't have an offsetParent\n    /** @type {?} */\n    let sibling;\n    while (offsetParent === noOffsetParent\n        && element.nextElementSibling\n        && sibling !== element.nextElementSibling) {\n        sibling = element.nextElementSibling;\n        offsetParent = sibling.offsetParent;\n    }\n    /** @type {?} */\n    const nodeName = offsetParent && offsetParent.nodeName;\n    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n        return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n    }\n    // .offsetParent will return the closest TH, TD or TABLE in case\n    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &&\n        getStyleComputedProperty(offsetParent, 'position') === 'static') {\n        return getOffsetParent(offsetParent);\n    }\n    return offsetParent;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction isOffsetContainer(element) {\n    const { nodeName } = element;\n    if (nodeName === 'BODY') {\n        return false;\n    }\n    return (nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @param {?} node\n * @return {?}\n */\nfunction getRoot(node) {\n    if (node.parentNode !== null) {\n        return getRoot(node.parentNode);\n    }\n    return node;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element1\n * @param {?} element2\n * @return {?}\n */\nfunction findCommonOffsetParent(element1, element2) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n        return document.documentElement;\n    }\n    // Here we make sure to give as \"start\" the element that comes first in the DOM\n    /* tslint:disable-next-line: no-bitwise */\n    /** @type {?} */\n    const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n    /** @type {?} */\n    const start = order ? element1 : element2;\n    /** @type {?} */\n    const end = order ? element2 : element1;\n    // Get common ancestor container\n    /** @type {?} */\n    const range = document.createRange();\n    range.setStart(start, 0);\n    range.setEnd(end, 0);\n    const { commonAncestorContainer } = range;\n    // Both nodes are inside #document\n    if ((element1 !== commonAncestorContainer &&\n        element2 !== commonAncestorContainer) ||\n        start.contains(end)) {\n        if (isOffsetContainer(commonAncestorContainer)) {\n            return commonAncestorContainer;\n        }\n        return getOffsetParent(commonAncestorContainer);\n    }\n    // one of the nodes is inside shadowDOM, find which one\n    /** @type {?} */\n    const element1root = getRoot(element1);\n    if (element1root.host) {\n        return findCommonOffsetParent(element1root.host, element2);\n    }\n    else {\n        return findCommonOffsetParent(element1, getRoot(element2).host);\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Helper to detect borders of a given element\n */\n/**\n * @param {?} styles\n * @param {?} axis\n * @return {?}\n */\nfunction getBordersSize(styles, axis) {\n    /** @type {?} */\n    const sideA = axis === 'x' ? 'Left' : 'Top';\n    /** @type {?} */\n    const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n    return (parseFloat(styles[(/** @type {?} */ (`border${sideA}Width`))]) +\n        parseFloat(styles[(/** @type {?} */ (`border${sideB}Width`))]));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} axis\n * @param {?} body\n * @param {?} html\n * @param {?} computedStyle\n * @return {?}\n */\nfunction getSize(axis, body, html, computedStyle) {\n    return Math.max(((/** @type {?} */ (body)))[`offset${axis}`], ((/** @type {?} */ (body)))[`scroll${axis}`], ((/** @type {?} */ (html)))[`client${axis}`], ((/** @type {?} */ (html)))[`offset${axis}`], ((/** @type {?} */ (html)))[`scroll${axis}`], isIE(10)\n        ? (parseInt(((/** @type {?} */ (html)))[`offset${axis}`], 10) +\n            parseInt(computedStyle[(/** @type {?} */ (`margin${axis === 'Height' ? 'Top' : 'Left'}`))], 10) +\n            parseInt(computedStyle[(/** @type {?} */ (`margin${axis === 'Height' ? 'Bottom' : 'Right'}`))], 10))\n        : 0);\n}\n/**\n * @param {?} document\n * @return {?}\n */\nfunction getWindowSizes(document) {\n    /** @type {?} */\n    const body = document.body;\n    /** @type {?} */\n    const html = document.documentElement;\n    /** @type {?} */\n    const computedStyle = isIE(10) && getComputedStyle(html);\n    return {\n        height: getSize('Height', body, html, computedStyle),\n        width: getSize('Width', body, html, computedStyle)\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @param {?} element\n * @param {?=} side\n * @return {?}\n */\nfunction getScroll(element, side = 'top') {\n    /** @type {?} */\n    const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n    /** @type {?} */\n    const nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        /** @type {?} */\n        const html = element.ownerDocument.documentElement;\n        /** @type {?} */\n        const scrollingElement = element.ownerDocument.scrollingElement || html;\n        return scrollingElement[upperSide];\n    }\n    return element[upperSide];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} offsets\n * @return {?}\n */\nfunction getClientRect(offsets) {\n    return Object.assign(Object.assign({}, offsets), { right: offsets.left + offsets.width, bottom: offsets.top + offsets.height });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction getBoundingClientRect(element) {\n    /** @type {?} */\n    let rect = {};\n    // IE10 10 FIX: Please, don't ask, the element isn't\n    // considered in DOM in some circumstances...\n    // This isn't reproducible in IE10 compatibility mode of IE11\n    try {\n        if (isIE(10)) {\n            rect = element.getBoundingClientRect();\n            /** @type {?} */\n            const scrollTop = getScroll(element, 'top');\n            /** @type {?} */\n            const scrollLeft = getScroll(element, 'left');\n            rect.top += scrollTop;\n            rect.left += scrollLeft;\n            rect.bottom += scrollTop;\n            rect.right += scrollLeft;\n        }\n        else {\n            rect = element.getBoundingClientRect();\n        }\n    }\n    catch (e) {\n        return undefined;\n    }\n    /** @type {?} */\n    const result = {\n        left: rect.left,\n        top: rect.top,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n    };\n    // subtract scrollbar size from sizes\n    /** @type {?} */\n    const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n    /** @type {?} */\n    const width = sizes.width || element.clientWidth || result.right - result.left;\n    /** @type {?} */\n    const height = sizes.height || element.clientHeight || result.bottom - result.top;\n    /** @type {?} */\n    let horizScrollbar = element.offsetWidth - width;\n    /** @type {?} */\n    let vertScrollbar = element.offsetHeight - height;\n    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n    // we make this check conditional for performance reasons\n    if (horizScrollbar || vertScrollbar) {\n        /** @type {?} */\n        const styles = getStyleComputedProperty(element);\n        horizScrollbar -= getBordersSize(styles, 'x');\n        vertScrollbar -= getBordersSize(styles, 'y');\n        result.width -= horizScrollbar;\n        result.height -= vertScrollbar;\n    }\n    return getClientRect(result);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} rect\n * @param {?} element\n * @param {?=} subtract\n * @return {?}\n */\nfunction includeScroll(rect, element, subtract = false) {\n    /** @type {?} */\n    const scrollTop = getScroll(element, 'top');\n    /** @type {?} */\n    const scrollLeft = getScroll(element, 'left');\n    /** @type {?} */\n    const modifier = subtract ? -1 : 1;\n    rect.top += scrollTop * modifier;\n    rect.bottom += scrollTop * modifier;\n    rect.left += scrollLeft * modifier;\n    rect.right += scrollLeft * modifier;\n    return rect;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} children\n * @param {?} parent\n * @param {?=} fixedPosition\n * @return {?}\n */\nfunction getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition = false) {\n    /** @type {?} */\n    const isIE10 = isIE(10);\n    /** @type {?} */\n    const isHTML = parent.nodeName === 'HTML';\n    /** @type {?} */\n    const childrenRect = getBoundingClientRect(children);\n    /** @type {?} */\n    const parentRect = getBoundingClientRect(parent);\n    /** @type {?} */\n    const scrollParent = getScrollParent(children);\n    /** @type {?} */\n    const styles = getStyleComputedProperty(parent);\n    /** @type {?} */\n    const borderTopWidth = parseFloat(styles.borderTopWidth);\n    /** @type {?} */\n    const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n    // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n    if (fixedPosition && isHTML) {\n        parentRect.top = Math.max(parentRect.top, 0);\n        parentRect.left = Math.max(parentRect.left, 0);\n    }\n    /** @type {?} */\n    let offsets = getClientRect({\n        top: childrenRect.top - parentRect.top - borderTopWidth,\n        left: childrenRect.left - parentRect.left - borderLeftWidth,\n        width: childrenRect.width,\n        height: childrenRect.height\n    });\n    offsets.marginTop = 0;\n    offsets.marginLeft = 0;\n    // Subtract margins of documentElement in case it's being used as parent\n    // we do this only on HTML because it's the only element that behaves\n    // differently when margins are applied to it. The margins are included in\n    // the box of the documentElement, in the other cases not.\n    if (!isIE10 && isHTML) {\n        /** @type {?} */\n        const marginTop = parseFloat(styles.marginTop);\n        /** @type {?} */\n        const marginLeft = parseFloat(styles.marginLeft);\n        offsets.top -= borderTopWidth - marginTop;\n        offsets.bottom -= borderTopWidth - marginTop;\n        offsets.left -= borderLeftWidth - marginLeft;\n        offsets.right -= borderLeftWidth - marginLeft;\n        // Attach marginTop and marginLeft because in some circumstances we may need them\n        offsets.marginTop = marginTop;\n        offsets.marginLeft = marginLeft;\n    }\n    if (isIE10 && !fixedPosition\n        ? parent.contains(scrollParent)\n        : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n        offsets = includeScroll(offsets, parent);\n    }\n    return offsets;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @param {?=} excludeScroll\n * @return {?}\n */\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) {\n    /** @type {?} */\n    const html = element.ownerDocument.documentElement;\n    /** @type {?} */\n    const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n    /** @type {?} */\n    const width = Math.max(html.clientWidth, window.innerWidth || 0);\n    /** @type {?} */\n    const height = Math.max(html.clientHeight, window.innerHeight || 0);\n    /** @type {?} */\n    const scrollTop = !excludeScroll ? getScroll(html) : 0;\n    /** @type {?} */\n    const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n    /** @type {?} */\n    const offset = {\n        top: scrollTop - Number(relativeOffset.top) + Number(relativeOffset.marginTop),\n        left: scrollLeft - Number(relativeOffset.left) + Number(relativeOffset.marginLeft),\n        width,\n        height\n    };\n    return getClientRect(offset);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction isFixed(element) {\n    /** @type {?} */\n    const nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        return false;\n    }\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n        return true;\n    }\n    return isFixed(getParentNode(element));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction getFixedPositionOffsetParent(element) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element || !element.parentElement || isIE()) {\n        return document.documentElement;\n    }\n    /** @type {?} */\n    let el = element.parentElement;\n    while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n        el = el.parentElement;\n    }\n    return el || document.documentElement;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} target\n * @param {?} host\n * @param {?=} padding\n * @param {?=} boundariesElement\n * @param {?=} fixedPosition\n * @return {?}\n */\nfunction getBoundaries(target, host, padding = 0, boundariesElement, fixedPosition = false) {\n    // NOTE: 1 DOM access here\n    // NOTE: 1 DOM access here\n    /** @type {?} */\n    let boundaries = { top: 0, left: 0 };\n    /** @type {?} */\n    const offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n    // Handle viewport case\n    if (boundariesElement === 'viewport') {\n        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n    }\n    else {\n        // Handle other cases based on DOM element used as boundaries\n        /** @type {?} */\n        let boundariesNode;\n        if (boundariesElement === 'scrollParent') {\n            boundariesNode = getScrollParent(getParentNode(host));\n            if (boundariesNode.nodeName === 'BODY') {\n                boundariesNode = target.ownerDocument.documentElement;\n            }\n        }\n        else if (boundariesElement === 'window') {\n            boundariesNode = target.ownerDocument.documentElement;\n        }\n        else {\n            boundariesNode = boundariesElement;\n        }\n        /** @type {?} */\n        const offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n        // In case of HTML, we need a different computation\n        if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n            const { height, width } = getWindowSizes(target.ownerDocument);\n            boundaries.top += offsets.top - offsets.marginTop;\n            boundaries.bottom = Number(height) + Number(offsets.top);\n            boundaries.left += offsets.left - offsets.marginLeft;\n            boundaries.right = Number(width) + Number(offsets.left);\n        }\n        else {\n            // for all the other DOM elements, this one is good\n            boundaries = offsets;\n        }\n    }\n    // Add paddings\n    boundaries.left += padding;\n    boundaries.top += padding;\n    boundaries.right -= padding;\n    boundaries.bottom -= padding;\n    return boundaries;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction getArea({ width, height }) {\n    return width * height;\n}\n/**\n * @param {?} placement\n * @param {?} refRect\n * @param {?} target\n * @param {?} host\n * @param {?=} allowedPositions\n * @param {?=} boundariesElement\n * @param {?=} padding\n * @return {?}\n */\nfunction computeAutoPlacement(placement, refRect, target, host, allowedPositions = ['top', 'bottom', 'right', 'left'], boundariesElement = 'viewport', padding = 0) {\n    if (placement.indexOf('auto') === -1) {\n        return placement;\n    }\n    /** @type {?} */\n    const boundaries = getBoundaries(target, host, padding, boundariesElement);\n    /** @type {?} */\n    const rects = {\n        top: {\n            width: boundaries.width,\n            height: refRect.top - boundaries.top\n        },\n        right: {\n            width: boundaries.right - refRect.right,\n            height: boundaries.height\n        },\n        bottom: {\n            width: boundaries.width,\n            height: boundaries.bottom - refRect.bottom\n        },\n        left: {\n            width: refRect.left - boundaries.left,\n            height: boundaries.height\n        }\n    };\n    /** @type {?} */\n    const sortedAreas = Object.keys(rects)\n        .map((/**\n     * @param {?} key\n     * @return {?}\n     */\n    key => (Object.assign(Object.assign({ key }, rects[key]), { area: getArea(rects[key]) }))))\n        .sort((/**\n     * @param {?} a\n     * @param {?} b\n     * @return {?}\n     */\n    (a, b) => b.area - a.area));\n    /** @type {?} */\n    let filteredAreas = sortedAreas.filter((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ({ width, height }) => {\n        return width >= target.clientWidth\n            && height >= target.clientHeight;\n    }));\n    filteredAreas = filteredAreas.filter((/**\n     * @param {?} position\n     * @return {?}\n     */\n    (position) => {\n        return allowedPositions\n            .some((/**\n         * @param {?} allowedPosition\n         * @return {?}\n         */\n        (allowedPosition) => {\n            return allowedPosition === position.key;\n        }));\n    }));\n    /** @type {?} */\n    const computedPlacement = filteredAreas.length > 0\n        ? filteredAreas[0].key\n        : sortedAreas[0].key;\n    /** @type {?} */\n    const variation = placement.split(' ')[1];\n    // for tooltip on auto position\n    target.className = target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${computedPlacement}`);\n    return computedPlacement + (variation ? `-${variation}` : '');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction getOffsets(data) {\n    return {\n        width: data.offsets.target.width,\n        height: data.offsets.target.height,\n        left: Math.floor(data.offsets.target.left),\n        top: Math.round(data.offsets.target.top),\n        bottom: Math.round(data.offsets.target.bottom),\n        right: Math.floor(data.offsets.target.right)\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Get the opposite placement of the given one\n * @param {?} placement\n * @return {?}\n */\nfunction getOppositePlacement(placement) {\n    /** @type {?} */\n    const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n    return placement.replace(/left|right|bottom|top/g, (/**\n     * @param {?} matched\n     * @return {?}\n     */\n    matched => ((/** @type {?} */ (hash)))[matched]));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Get the opposite placement variation of the given one\n * @param {?} variation\n * @return {?}\n */\nfunction getOppositeVariation(variation) {\n    if (variation === 'right') {\n        return 'left';\n    }\n    else if (variation === 'left') {\n        return 'right';\n    }\n    return variation;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @param {?} element\n * @return {?}\n */\nfunction getOuterSizes(element) {\n    /** @type {?} */\n    const window = element.ownerDocument.defaultView;\n    /** @type {?} */\n    const styles = window.getComputedStyle(element);\n    /** @type {?} */\n    const x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n    /** @type {?} */\n    const y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n    return {\n        width: Number(element.offsetWidth) + y,\n        height: Number(element.offsetHeight) + x\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} target\n * @param {?} host\n * @param {?=} fixedPosition\n * @return {?}\n */\nfunction getReferenceOffsets(target, host, fixedPosition = null) {\n    /** @type {?} */\n    const commonOffsetParent = fixedPosition\n        ? getFixedPositionOffsetParent(target)\n        : findCommonOffsetParent(target, host);\n    return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} target\n * @param {?} hostOffsets\n * @param {?} position\n * @return {?}\n */\nfunction getTargetOffsets(target, hostOffsets, position) {\n    /** @type {?} */\n    const placement = position.split(' ')[0];\n    // Get target node sizes\n    /** @type {?} */\n    const targetRect = getOuterSizes(target);\n    // Add position, width and height to our offsets object\n    /** @type {?} */\n    const targetOffsets = {\n        width: targetRect.width,\n        height: targetRect.height\n    };\n    // depending by the target placement we have to compute its offsets slightly differently\n    /** @type {?} */\n    const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n    /** @type {?} */\n    const mainSide = isHoriz ? 'top' : 'left';\n    /** @type {?} */\n    const secondarySide = isHoriz ? 'left' : 'top';\n    /** @type {?} */\n    const measurement = isHoriz ? 'height' : 'width';\n    /** @type {?} */\n    const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n    ((/** @type {?} */ (targetOffsets)))[mainSide] =\n        hostOffsets[mainSide] +\n            hostOffsets[measurement] / 2 -\n            targetRect[measurement] / 2;\n    ((/** @type {?} */ (targetOffsets)))[secondarySide] = placement === secondarySide\n        ? hostOffsets[secondarySide] - targetRect[secondaryMeasurement]\n        : ((/** @type {?} */ (hostOffsets)))[getOppositePlacement(secondarySide)];\n    return targetOffsets;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Helper used to know if the given modifier is enabled.\n * @param {?} options\n * @param {?} modifierName\n * @return {?}\n */\nfunction isModifierEnabled(options, modifierName) {\n    return options\n        && options.modifiers\n        && options.modifiers[modifierName]\n        && options.modifiers[modifierName].enabled;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Tells if a given input is a number\n * @param {?} n\n * @return {?}\n */\nfunction isNumeric(n) {\n    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @param {?=} renderer\n * @return {?}\n */\nfunction updateContainerClass(data, renderer) {\n    /** @type {?} */\n    const target = data.instance.target;\n    /** @type {?} */\n    let containerClass = target.className;\n    if (data.placementAuto) {\n        containerClass = containerClass.replace(/bs-popover-auto/g, `bs-popover-${data.placement}`);\n        containerClass = containerClass.replace(/bs-tooltip-auto/g, `bs-tooltip-${data.placement}`);\n        containerClass = containerClass.replace(/\\sauto/g, ` ${data.placement}`);\n        if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\n            containerClass += ' popover-auto';\n        }\n        if (containerClass.indexOf('tooltip') !== -1 && containerClass.indexOf('tooltip-auto') === -1) {\n            containerClass += ' tooltip-auto';\n        }\n    }\n    containerClass = containerClass.replace(/left|right|top|bottom/g, `${data.placement.split(' ')[0]}`);\n    if (renderer) {\n        renderer.setAttribute(target, 'class', containerClass);\n        return;\n    }\n    target.className = containerClass;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @param {?} styles\n * @param {?=} renderer\n * @return {?}\n */\nfunction setStyles(element, styles, renderer) {\n    Object.keys(styles).forEach((/**\n     * @param {?} prop\n     * @return {?}\n     */\n    (prop) => {\n        /** @type {?} */\n        let unit = '';\n        // add unit if the value is numeric and is one of the following\n        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 &&\n            isNumeric(styles[prop])) {\n            unit = 'px';\n        }\n        if (renderer) {\n            renderer.setStyle(element, prop, `${String(styles[prop])}${unit}`);\n            return;\n        }\n        element.style[prop] = String(styles[prop]) + unit;\n    }));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction arrow(data) {\n    /** @type {?} */\n    let targetOffsets = data.offsets.target;\n    // if arrowElement is a string, suppose it's a CSS selector\n    /** @type {?} */\n    const arrowElement = data.instance.target.querySelector('.arrow');\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n        return data;\n    }\n    /** @type {?} */\n    const isVertical = ['left', 'right'].indexOf(data.placement.split(' ')[0]) !== -1;\n    /** @type {?} */\n    const len = isVertical ? 'height' : 'width';\n    /** @type {?} */\n    const sideCapitalized = isVertical ? 'Top' : 'Left';\n    /** @type {?} */\n    const side = sideCapitalized.toLowerCase();\n    /** @type {?} */\n    const altSide = isVertical ? 'left' : 'top';\n    /** @type {?} */\n    const opSide = isVertical ? 'bottom' : 'right';\n    /** @type {?} */\n    const arrowElementSize = getOuterSizes(arrowElement)[len];\n    /** @type {?} */\n    const placementVariation = data.placement.split(' ')[1];\n    // top/left side\n    if (data.offsets.host[opSide] - arrowElementSize < ((/** @type {?} */ (targetOffsets)))[side]) {\n        ((/** @type {?} */ (targetOffsets)))[side] -=\n            ((/** @type {?} */ (targetOffsets)))[side] - (data.offsets.host[opSide] - arrowElementSize);\n    }\n    // bottom/right side\n    if (Number(((/** @type {?} */ (data))).offsets.host[side]) + Number(arrowElementSize) > ((/** @type {?} */ (targetOffsets)))[opSide]) {\n        ((/** @type {?} */ (targetOffsets)))[side] +=\n            Number(((/** @type {?} */ (data))).offsets.host[side]) + Number(arrowElementSize) - Number(((/** @type {?} */ (targetOffsets)))[opSide]);\n    }\n    targetOffsets = getClientRect(targetOffsets);\n    // Compute the sideValue using the updated target offsets\n    // take target margin in account because we don't have this info available\n    /** @type {?} */\n    const css = getStyleComputedProperty(data.instance.target);\n    /** @type {?} */\n    const targetMarginSide = parseFloat(css[`margin${sideCapitalized}`]);\n    /** @type {?} */\n    const targetBorderSide = parseFloat(css[`border${sideCapitalized}Width`]);\n    // compute center of the target\n    /** @type {?} */\n    let center;\n    if (!placementVariation) {\n        center = Number(((/** @type {?} */ (data))).offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n    }\n    else {\n        /** @type {?} */\n        const targetBorderRadius = parseFloat(css.borderRadius);\n        /** @type {?} */\n        const targetSideArrowOffset = Number(targetMarginSide + targetBorderSide + targetBorderRadius);\n        center = side === placementVariation ?\n            Number(((/** @type {?} */ (data))).offsets.host[side]) + targetSideArrowOffset :\n            Number(((/** @type {?} */ (data))).offsets.host[side]) + Number(data.offsets.host[len] - targetSideArrowOffset);\n    }\n    /** @type {?} */\n    let sideValue = center - ((/** @type {?} */ (targetOffsets)))[side] - targetMarginSide - targetBorderSide;\n    // prevent arrowElement from being placed not contiguously to its target\n    sideValue = Math.max(Math.min(targetOffsets[len] - arrowElementSize, sideValue), 0);\n    data.offsets.arrow = {\n        [side]: Math.round(sideValue),\n        [altSide]: '' // make sure to unset any eventual altSide value from the DOM node\n    };\n    data.instance.arrow = arrowElement;\n    return data;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction flip(data) {\n    data.offsets.target = getClientRect(data.offsets.target);\n    if (!isModifierEnabled(data.options, 'flip')) {\n        data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n        return data;\n    }\n    /** @type {?} */\n    const boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n    'viewport', false // positionFixed\n    );\n    /** @type {?} */\n    let placement = data.placement.split(' ')[0];\n    /** @type {?} */\n    let variation = data.placement.split(' ')[1] || '';\n    /** @type {?} */\n    const offsetsHost = data.offsets.host;\n    /** @type {?} */\n    const target = data.instance.target;\n    /** @type {?} */\n    const host = data.instance.host;\n    /** @type {?} */\n    const adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\n    /** @type {?} */\n    const flipOrder = [placement, adaptivePosition];\n    /* tslint:disable-next-line: cyclomatic-complexity */\n    flipOrder.forEach((/**\n     * @param {?} step\n     * @param {?} index\n     * @return {?}\n     */\n    (step, index) => {\n        if (placement !== step || flipOrder.length === index + 1) {\n            return data;\n        }\n        placement = data.placement.split(' ')[0];\n        // using floor because the host offsets may contain decimals we are not going to consider here\n        /** @type {?} */\n        const overlapsRef = (placement === 'left' &&\n            Math.floor(data.offsets.target.right) > Math.floor(data.offsets.host.left)) ||\n            (placement === 'right' &&\n                Math.floor(data.offsets.target.left) < Math.floor(data.offsets.host.right)) ||\n            (placement === 'top' &&\n                Math.floor(data.offsets.target.bottom) > Math.floor(data.offsets.host.top)) ||\n            (placement === 'bottom' &&\n                Math.floor(data.offsets.target.top) < Math.floor(data.offsets.host.bottom));\n        /** @type {?} */\n        const overflowsLeft = Math.floor(data.offsets.target.left) < Math.floor(boundaries.left);\n        /** @type {?} */\n        const overflowsRight = Math.floor(data.offsets.target.right) > Math.floor(boundaries.right);\n        /** @type {?} */\n        const overflowsTop = Math.floor(data.offsets.target.top) < Math.floor(boundaries.top);\n        /** @type {?} */\n        const overflowsBottom = Math.floor(data.offsets.target.bottom) > Math.floor(boundaries.bottom);\n        /** @type {?} */\n        const overflowsBoundaries = (placement === 'left' && overflowsLeft) ||\n            (placement === 'right' && overflowsRight) ||\n            (placement === 'top' && overflowsTop) ||\n            (placement === 'bottom' && overflowsBottom);\n        // flip the variation if required\n        /** @type {?} */\n        const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n        /** @type {?} */\n        const flippedVariation = ((isVertical && variation === 'left' && overflowsLeft) ||\n            (isVertical && variation === 'right' && overflowsRight) ||\n            (!isVertical && variation === 'left' && overflowsTop) ||\n            (!isVertical && variation === 'right' && overflowsBottom));\n        if (overlapsRef || overflowsBoundaries || flippedVariation) {\n            if (overlapsRef || overflowsBoundaries) {\n                placement = flipOrder[index + 1];\n            }\n            if (flippedVariation) {\n                variation = getOppositeVariation(variation);\n            }\n            data.placement = placement + (variation ? ` ${variation}` : '');\n            data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n        }\n    }));\n    return data;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} targetElement\n * @param {?} hostElement\n * @param {?} position\n * @param {?} options\n * @return {?}\n */\nfunction initData(targetElement, hostElement, position, options) {\n    /** @type {?} */\n    const hostElPosition = getReferenceOffsets(targetElement, hostElement);\n    if (!position.match(/^(auto)*\\s*(left|right|top|bottom)*$/)\n        && !position.match(/^(left|right|top|bottom)*(?: (left|right|top|bottom))?\\s*(start|end)*$/)) {\n        /* tslint:disable-next-line: no-parameter-reassignment */\n        position = 'auto';\n    }\n    /** @type {?} */\n    const placementAuto = !!position.match(/auto/g);\n    // support old placements 'auto left|right|top|bottom'\n    /** @type {?} */\n    let placement = position.match(/auto\\s(left|right|top|bottom)/)\n        ? position.split(' ')[1] || 'auto'\n        : position;\n    // Normalize placements that have identical main placement and variation (\"right right\" => \"right\").\n    /** @type {?} */\n    const matches = placement.match(/^(left|right|top|bottom)* ?(?!\\1)(left|right|top|bottom)?/);\n    if (matches) {\n        placement = matches[1] + (matches[2] ? ` ${matches[2]}` : '');\n    }\n    // \"left right\", \"top bottom\" etc. placements also considered incorrect.\n    if (['left right', 'right left', 'top bottom', 'bottom top'].indexOf(placement) !== -1) {\n        placement = 'auto';\n    }\n    /** @type {?} */\n    const targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n    placement = computeAutoPlacement(placement, hostElPosition, targetElement, hostElement, options ? options.allowedPositions : undefined);\n    return {\n        options,\n        instance: {\n            target: targetElement,\n            host: hostElement,\n            arrow: null\n        },\n        offsets: {\n            target: targetOffset,\n            host: hostElPosition,\n            arrow: null\n        },\n        positionFixed: false,\n        placement,\n        placementAuto\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction preventOverflow(data) {\n    if (!isModifierEnabled(data.options, 'preventOverflow')) {\n        return data;\n    }\n    // NOTE: DOM access here\n    // resets the targetOffsets's position so that the document size can be calculated excluding\n    // the size of the targetOffsets element itself\n    /** @type {?} */\n    const transformProp = 'transform';\n    /** @type {?} */\n    const targetStyles = data.instance.target.style;\n    // assignment to help minification\n    const { top, left, [transformProp]: transform } = targetStyles;\n    targetStyles.top = '';\n    targetStyles.left = '';\n    targetStyles[transformProp] = '';\n    /** @type {?} */\n    const boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n    'scrollParent', false // positionFixed\n    );\n    // NOTE: DOM access here\n    // restores the original style properties after the offsets have been computed\n    targetStyles.top = top;\n    targetStyles.left = left;\n    targetStyles[transformProp] = transform;\n    /** @type {?} */\n    const order = ['left', 'right', 'top', 'bottom'];\n    /** @type {?} */\n    const check = {\n        /**\n         * @param {?} placement\n         * @return {?}\n         */\n        primary(placement) {\n            /** @type {?} */\n            let value = ((/** @type {?} */ (data))).offsets.target[placement];\n            if (((/** @type {?} */ (data))).offsets.target[placement] < boundaries[placement] &&\n                !false // options.escapeWithReference\n            ) {\n                value = Math.max(((/** @type {?} */ (data))).offsets.target[placement], boundaries[placement]);\n            }\n            return { [placement]: value };\n        },\n        /**\n         * @param {?} placement\n         * @return {?}\n         */\n        secondary(placement) {\n            /** @type {?} */\n            const mainSide = placement === 'right' ? 'left' : 'top';\n            /** @type {?} */\n            let value = data.offsets.target[mainSide];\n            if (((/** @type {?} */ (data))).offsets.target[placement] > boundaries[placement] &&\n                !false // escapeWithReference\n            ) {\n                value = Math.min(data.offsets.target[mainSide], boundaries[placement] -\n                    (placement === 'right' ? data.offsets.target.width : data.offsets.target.height));\n            }\n            return { [mainSide]: value };\n        }\n    };\n    /** @type {?} */\n    let side;\n    order.forEach((/**\n     * @param {?} placement\n     * @return {?}\n     */\n    placement => {\n        side = ['left', 'top']\n            .indexOf(placement) !== -1\n            ? 'primary'\n            : 'secondary';\n        data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), ((/** @type {?} */ (check)))[side](placement));\n    }));\n    return data;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction shift(data) {\n    /** @type {?} */\n    const placement = data.placement;\n    /** @type {?} */\n    const basePlacement = placement.split(' ')[0];\n    /** @type {?} */\n    const shiftVariation = placement.split(' ')[1];\n    if (shiftVariation) {\n        const { host, target } = data.offsets;\n        /** @type {?} */\n        const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n        /** @type {?} */\n        const side = isVertical ? 'left' : 'top';\n        /** @type {?} */\n        const measurement = isVertical ? 'width' : 'height';\n        /** @type {?} */\n        const shiftOffsets = {\n            start: { [side]: host[side] },\n            end: {\n                [side]: host[side] + host[measurement] - target[measurement]\n            }\n        };\n        data.offsets.target = Object.assign(Object.assign({}, target), {\n            [side]: (side === shiftVariation ? ((/** @type {?} */ (shiftOffsets))).start[side] : ((/** @type {?} */ (shiftOffsets))).end[side])\n        });\n    }\n    return data;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass Positioning {\n    /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @param {?=} round\n     * @return {?}\n     */\n    position(hostElement, targetElement, round = true) {\n        return this.offset(hostElement, targetElement, false);\n    }\n    /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @param {?=} round\n     * @return {?}\n     */\n    offset(hostElement, targetElement, round = true) {\n        return getReferenceOffsets(targetElement, hostElement);\n    }\n    /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @param {?} position\n     * @param {?=} appendToBody\n     * @param {?=} options\n     * @return {?}\n     */\n    positionElements(hostElement, targetElement, position, appendToBody, options) {\n        /** @type {?} */\n        const chainOfModifiers = [flip, shift, preventOverflow, arrow];\n        return chainOfModifiers.reduce((/**\n         * @param {?} modifiedData\n         * @param {?} modifier\n         * @return {?}\n         */\n        (modifiedData, modifier) => modifier(modifiedData)), initData(targetElement, hostElement, position, options));\n    }\n}\n/** @type {?} */\nconst positionService = new Positioning();\n/**\n * @param {?} hostElement\n * @param {?} targetElement\n * @param {?} placement\n * @param {?=} appendToBody\n * @param {?=} options\n * @param {?=} renderer\n * @return {?}\n */\nfunction positionElements(hostElement, targetElement, placement, appendToBody, options, renderer) {\n    /** @type {?} */\n    const data = positionService.positionElements(hostElement, targetElement, placement, appendToBody, options);\n    /** @type {?} */\n    const offsets = getOffsets(data);\n    setStyles(targetElement, {\n        'will-change': 'transform',\n        top: '0px',\n        left: '0px',\n        transform: `translate3d(${offsets.left}px, ${offsets.top}px, 0px)`\n    }, renderer);\n    if (data.instance.arrow) {\n        setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n    }\n    updateContainerClass(data, renderer);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nfunction PositioningOptions() { }\nif (false) {\n    /**\n     * The DOM element, ElementRef, or a selector string of an element which will be moved\n     * @type {?|undefined}\n     */\n    PositioningOptions.prototype.element;\n    /**\n     * The DOM element, ElementRef, or a selector string of an element which the element will be attached to\n     * @type {?|undefined}\n     */\n    PositioningOptions.prototype.target;\n    /**\n     * A string of the form 'vert-attachment horiz-attachment' or 'placement'\n     * - placement can be \"top\", \"bottom\", \"left\", \"right\"\n     * not yet supported:\n     * - vert-attachment can be any of 'top', 'middle', 'bottom'\n     * - horiz-attachment can be any of 'left', 'center', 'right'\n     * @type {?|undefined}\n     */\n    PositioningOptions.prototype.attachment;\n    /**\n     * A string similar to `attachment`. The one difference is that, if it's not provided,\n     * `targetAttachment` will assume the mirror image of `attachment`.\n     * @type {?|undefined}\n     */\n    PositioningOptions.prototype.targetAttachment;\n    /**\n     * A string of the form 'vert-offset horiz-offset'\n     * - vert-offset and horiz-offset can be of the form \"20px\" or \"55%\"\n     * @type {?|undefined}\n     */\n    PositioningOptions.prototype.offset;\n    /**\n     * A string similar to `offset`, but referring to the offset of the target\n     * @type {?|undefined}\n     */\n    PositioningOptions.prototype.targetOffset;\n    /**\n     * If true component will be attached to body\n     * @type {?|undefined}\n     */\n    PositioningOptions.prototype.appendToBody;\n}\nclass PositioningService {\n    /**\n     * @param {?} ngZone\n     * @param {?} rendererFactory\n     * @param {?} platformId\n     */\n    constructor(ngZone, rendererFactory, platformId) {\n        this.update$$ = new Subject();\n        this.positionElements = new Map();\n        this.isDisabled = false;\n        if (isPlatformBrowser(platformId)) {\n            ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                this.triggerEvent$ = merge(fromEvent(window, 'scroll', { passive: true }), fromEvent(window, 'resize', { passive: true }), \n                /* tslint:disable-next-line: deprecation */\n                of(0, animationFrameScheduler), this.update$$);\n                this.triggerEvent$.subscribe((/**\n                 * @return {?}\n                 */\n                () => {\n                    if (this.isDisabled) {\n                        return;\n                    }\n                    this.positionElements\n                        /* tslint:disable-next-line: no-any */\n                        .forEach((/**\n                     * @param {?} positionElement\n                     * @return {?}\n                     */\n                    (positionElement) => {\n                        positionElements(_getHtmlElement(positionElement.target), _getHtmlElement(positionElement.element), positionElement.attachment, positionElement.appendToBody, this.options, rendererFactory.createRenderer(null, null));\n                    }));\n                }));\n            }));\n        }\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    position(options) {\n        this.addPositionElement(options);\n    }\n    /**\n     * @return {?}\n     */\n    get event$() {\n        return this.triggerEvent$;\n    }\n    /**\n     * @return {?}\n     */\n    disable() {\n        this.isDisabled = true;\n    }\n    /**\n     * @return {?}\n     */\n    enable() {\n        this.isDisabled = false;\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    addPositionElement(options) {\n        this.positionElements.set(_getHtmlElement(options.element), options);\n    }\n    /**\n     * @return {?}\n     */\n    calcPosition() {\n        this.update$$.next();\n    }\n    /**\n     * @param {?} elRef\n     * @return {?}\n     */\n    deletePositionElement(elRef) {\n        this.positionElements.delete(_getHtmlElement(elRef));\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    setOptions(options) {\n        this.options = options;\n    }\n}\nPositioningService.ɵfac = function PositioningService_Factory(t) { return new (t || PositioningService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2), ɵngcc0.ɵɵinject(PLATFORM_ID)); };\nPositioningService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: PositioningService, factory: PositioningService.ɵfac });\n/** @nocollapse */\nPositioningService.ctorParameters = () => [\n    { type: NgZone },\n    { type: RendererFactory2 },\n    { type: Number, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PositioningService, [{\n        type: Injectable\n    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.RendererFactory2 }, { type: Number, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, null); })();\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    PositioningService.prototype.options;\n    /**\n     * @type {?}\n     * @private\n     */\n    PositioningService.prototype.update$$;\n    /**\n     * @type {?}\n     * @private\n     */\n    PositioningService.prototype.positionElements;\n    /**\n     * @type {?}\n     * @private\n     */\n    PositioningService.prototype.triggerEvent$;\n    /**\n     * @type {?}\n     * @private\n     */\n    PositioningService.prototype.isDisabled;\n}\n/**\n * @param {?} element\n * @return {?}\n */\nfunction _getHtmlElement(element) {\n    // it means that we got a selector\n    if (typeof element === 'string') {\n        return document.querySelector(element);\n    }\n    if (element instanceof ElementRef) {\n        return element.nativeElement;\n    }\n    return element;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { Positioning, PositioningService, positionElements };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}